#!/usr/bin/env python3

"""System maintenance and update utility.

This script provides an unified interface for maintaining and updating the software
across multiple environments. Depending on the Operating Systems, installed package
managers and active shell, the script can perform;

    - Linux distribution updates using the appropriate package manager.
    - Homebrew package updates on MacOS or Linux systems where Homebrew is installed.
    - Zsh plugin updates for users running the Zsh shell with plugin repositories stored
        under `~/.zsh/plugins`.

The script determines which update routines to run based on environment inspection
rather than user input, making it suitable for automated maintenance tasks or periodic
system cleanup.

Errors from subprocess commands (such as package manager failures) may propagate unless
caught internally, ensuring misconfigurations or unexpected system states are not
silently ignored.

Author: Somraj Saha <contact@jarmos.dev>
License: MIT
"""

import argparse
import datetime
import logging
import os
import pathlib
import platform
import shlex
import subprocess
import sys
import time
import typing
from concurrent.futures import ThreadPoolExecutor, as_completed


class LogFormatter(logging.Formatter):
    """A log formatter which adds ANSI colours and aligns the level tag.

    The colour is applied to the entire bracketed level tag, while the message text
    remains uncoloured. The tags are padded to `LABEL_WIDTH` characters to keep log
    messages in a neatly aligned column.

    Attributes:
        colours: Mapping of log levels to ANSI colour codes.
        reset: ANSI escape sequence used to reset terminal colours.
        label_width: Target width (in visible characters) for the bracketed log-level
            label, e.g. "[CRITICAL]".
    """

    # Set the timestamps to be in UTC
    converter = time.gmtime  # type: ignore

    # Set the ANSI colour codes for levels
    colours: typing.ClassVar = {
        logging.DEBUG: "\033[36m",  # Cyan
        logging.INFO: "\033[32m",  # Green
        logging.WARNING: "\033[33m",  # Yellow
        logging.ERROR: "\033[31m",  # Red
        logging.CRITICAL: "\033[41m",  # Red background
    }

    # Remove the ANSI colour code for levels
    reset = "\033[0m"

    @typing.override
    def format(self, record: logging.LogRecord) -> str:
        """Format a log record with coloured and padded level labels.

        Args:
            record: The log record being formatted.

        Returns:
            A coloured and aligned log message string.
        """
        colour = self.colours.get(record.levelno, self.reset)
        record.coloured_levelname = f"{colour}{record.levelname}{self.reset}"

        return super().format(record)


def configure_logging(level: int) -> logging.Logger:
    """Configure and return a console logger.

    This function creates (or retrieves) a logger with a given name, set it's logging
    level and attaches a stream handler with a custom formatted log message if no
    handlers are already present.

    Args:
        level: The logging level to be set on the logger and its handler (e.g.,
            `logging.DEBUG`, `logging.INFO`).

    Returns:
        A configured `logging.Logger` instance.
    """
    # Get a logger and set it's name to the name of the current module
    logger = logging.getLogger(__name__)

    # Set the logging level for the root log handler
    logger.setLevel(level)

    # Format the log message to provide contextual information about the log level name
    # and its associated log message
    fmt = LogFormatter(
        "%(asctime)s %(coloured_levelname)-9s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z",
    )

    # Attach a log handler to print the log messages to STDOUT
    if not logger.handlers:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        console_handler.setFormatter(fmt)
        logger.addHandler(console_handler)

    return logger


def parse_args() -> argparse.Namespace:
    """Parse and return the CLI arguments.

    Returns:
        An argparse.Namespace object containing the parsed arguments.
    """
    current_year = datetime.datetime.now(datetime.timezone.utc).year
    description = "intelligently update the system packages"
    epilog = f"Â© Somraj Saha 2018-{current_year} <contact@jarmos.dev>"

    parser = argparse.ArgumentParser(description=description, epilog=epilog)

    parser.add_argument(
        "--debug",
        action="store_true",
        help="the optional flag to enable debug mode",
    )

    return parser.parse_args()


def run(
    cmd: str,
    *,
    logger: logging.Logger,
    cwd: pathlib.Path | None = None,
    capture_output: bool = False,
    shell: bool = False,
) -> str | None:
    """Execute an external command with controlled output.

    The subprocess output is supressed unless DEBUG logging is enabled. On failure,
    captured output is logged at the ERROR level.

    Args:
        cmd (str): Command and arguments to execute.
        logger (logging.Logger): Logger used for debug output.
        cwd (pathlib.Path | None): Optional working directory for the command.
        capture_output (bool): Whether to the capture the output of the command and
            store in a Python variable.
        shell (bool): Whether to use the current shell to run the command.

    Raises:
        subprocess.CalledProcessError: If the command exits with a non-zero code.
    """
    logger.debug('Executing "%s"', cmd)
    debug_enabled = logger.isEnabledFor(logging.DEBUG)
    args = cmd if shell else shlex.split(cmd)

    if capture_output:
        try:
            return subprocess.run(
                args,
                cwd=cwd,
                check=True,
                text=True,
                capture_output=capture_output,
                shell=shell,
            ).stdout.strip()
        except subprocess.CalledProcessError:
            logger.exception("Command failed: %s", cmd)
            raise
    else:
        try:
            subprocess.run(
                args,
                cwd=cwd,
                check=True,
                text=False,
                stdout=None if debug_enabled else subprocess.PIPE,
                stderr=None if debug_enabled else subprocess.PIPE,
                shell=shell,
            )

            return None
        except subprocess.CalledProcessError:
            logger.exception("Command failed: %s", cmd)
            raise


def run_linux_updates(logger: logging.Logger) -> None:
    """Detect the Linux distribution and run system updates accordingly.

    Supported distributions:
      - Ubuntu (apt-get)
      - Debian (apt-get)
      - Fedora (dnf)

    This function executes the appropriate package manager commands for
    updating system packages and removing unused dependencies. It uses
    `run(...)` to ensure errors are surfaced.

    If the distribution is not recognized, the function logs an error
    and terminates the program with a non-zero exit code.

    Args:
        level (logging.Logger): The `Logger` instance used for logging useful messages
            when running the updates for a particular distribution.

    Returns: None
    """
    distro = platform.freedesktop_os_release().get("NAME", "")

    logger.debug("Identified Linux distrubution: %s", distro)

    match distro:
        case "Ubuntu" | "Debian":
            logger.info("Updating %s system...", distro)
            run(
                "sudo apt-get update && "
                + "sudo apt-get upgrade --yes && "
                + "sudo apt-get autoremove --purge --yes",
                shell=True,
                logger=logger,
            )
            logger.info("%s APT packages upgrade complete!", distro)
        case "Fedora":
            logger.info("Updating %s system...", distro)
            run(
                "sudo dnf upgrade --assumeyes && " + "sudo dnf autoremove --assumeyes",
                shell=True,
                logger=logger,
            )
            logger.info("%s APT packages upgrade complete!", distro)
        case _:
            logger.error("Failed to identify system information...exiting!")
            sys.exit(1)


def homebrew_installed(logger: logging.Logger) -> bool:
    """Determine whether Homebrew is installed and accessible.

    This function checks for the presence of the `brew` executable by attempting to run
    `brew --version`. No output is displayed during the check.

    Args:
        logger (logging.Logger): The `Logger` instance to display useful information to
            the STDOUT when checking if Homebrew is installed.

    Returns:
        `True`: Homebrew is installed and the `brew` command can be executed.
        `False`: Homebrew is not installed, not available on the system `PATH` or
            returned an unexpected error during its execution.
    """
    try:
        logger.debug("Checking if Homebrew is installed...")
        version = run("brew --version", capture_output=True, logger=logger)
        logger.debug(
            'Homebrew installed, identified version information: "%s"', version
        )
        return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False


def run_homebrew_updates(logger: logging.Logger) -> None:
    """Run system package updates using Homebrew.

    This function executes the standard Homebrew maintenance sequence:
        - `brew update` to refresh the available package definitions.
        - `brew upgrade` to upgrade installed formulae and casks.
        - `brew autoremove` to removed unused dependency packages.
        - `brew cleanup` to remove outdated files and cached data.

    All the commands are executed with the `check=True` parameter to raise a
    `subprocess.CalledProcessError` to be raised if any step fails.

    Args:
        logger (logging.Logger): The `Logger` instance used for logging useful messages
            to STDOUT when performing some Homebrew updates.

    Raises:
        subprocess.CalledProcessError: If any Homebrew command exits with a non-zero
            status.

    Returns: None
    """
    logger.info("Running Homebrew updates")
    run(
        "brew update && " + "brew upgrade && " + "brew autoremove && " + "brew cleanup",
        shell=True,
        logger=logger,
    )
    logger.info("Homebrew package upgrades complete!")


def run_zsh_updates(logger: logging.Logger) -> None:
    """Update the local Zsh plugins by pulling the latest changes.

    This function assumes the Zsh plugins are cloned under:
        `~/.zsh/plugins/<PLUGIN-NAME>`

    For each plugin repository listed in the `plugins` tuple, the function:
        1. Constructs the local plugin directory path.
        2. Changes the working directory to that location.
        3. Executes `git pull --rebase` to fetch and apply the upstream updates.

    All Git operations are executed with `check=True`, causing
    `subprocess.CalledProcessError` to be raised if any update fails.

    logger (logging.Logger): The `Logger` instance used for logging useful messages to
        STDOUT when updating the ZSH plugins.

    Raises:
        `FileNotFoundError`: If a plugin directory does not exist.
        `subprocess.CalledProcessError`: If a Git update operation exits with a non-zero
            status.

    Returns: None
    """
    plugins = (
        "zsh-users/zsh-autosuggestions",
        "ael-code/zsh-colored-man-pages",
        "zsh-users/zsh-completions",
        "zsh-users/zsh-syntax-highlighting",
    )

    logger.info("Running ZSH plugin updates")

    def update(plugin: str) -> None:
        cwd = pathlib.Path.home() / ".zsh" / "plugins" / plugin.split("/")[-1]
        run("git pull --rebase", cwd=cwd, logger=logger)

    with ThreadPoolExecutor(max_workers=min(4, len(plugins))) as pool:
        futures = [pool.submit(update, plugin) for plugin in plugins]
        for future in as_completed(futures):
            future.result()

    logger.info("ZSH update plugins complete!")


def main(logger: logging.Logger) -> None:
    """Executes the full system update routine for the current environment.

    This function orchestrates all available update mechanisms based on the system
    configuration and installed tooling:

        1. Parses the CLI arguments for the script.
        2. Detects the active shell via the `SHELL` environment variable.
        3. If running on Linux system, executes OS-level package updates.
        4. If Homebrew is installed, runs Homebrew package maintenance.
        5. If the active shell is Zsh, updates the Zsh plugins.

    The function prints progress messages and ends with a success message once all
    relevant update routines have completed. Errors from underlying update handlers
    (such as failed subprocess calls) may propagate upwards unless explicitly handled
    within those functions.

    Args:
        logger (logging.Logger): The `Logger` instance to display useful information to
            STDOUT when running the script.

    Returns: None

    Raises:
        subprocess.CalledProcessError: If any invoked update command (Linux, Homebrew
            or Zsh plugin updates) fails and is executed with `check=True`.
    """
    # Chech which shell is enabled for the interactive environment
    shell = os.getenv("SHELL")

    # Run the package updates for a Linux distribution
    if platform.uname().system == "Linux":
        run("sudo -v", logger=logger)
        run_linux_updates(logger)

    # Run the Homebrew package updates
    if homebrew_installed(logger):
        run_homebrew_updates(logger)

    # Update the zsh plugins
    if shell and shell.split("/")[-1] == "zsh":
        run_zsh_updates(logger)

    logger.info("System update complete...exiting now")


if __name__ == "__main__":
    # Parse the CLI arguments of the script
    args = parse_args()

    # Create a logger
    level = logging.INFO if not args.debug else logging.DEBUG
    logger = configure_logging(level)

    try:
        main(logger)
    except KeyboardInterrupt:
        logger.warning("System updated interrupted manually...")
        sys.exit(2)
