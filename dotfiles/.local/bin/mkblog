#!/usr/bin/env python3

"""
Script to generate and automate the process of creating a blogpost.

The script takes user input, either through STDIN or CLI flags to generate a Markdown
file for my blog. The intention of using the script for the purpose is to reproducibly
generate and manage each Markdown file along with some necessary metadata which can be
quite cumbersome to remember every time.

Author: Somraj Saha <contact@jarmos.dev>
License: MIT (see the LICENSE document for more details)

TODO: Provide a usage guide.
"""

import argparse
import datetime
import os
import pathlib
import re
import subprocess
from dataclasses import dataclass

# The current timestamp during the template generation process
_TIME = datetime.datetime.now(datetime.timezone.utc)
_BLOG_DIR = pathlib.Path.home() / "projects" / "blogposts" / "blogs"

# Message labels with their respective ANSI colour codes
_RESET = "\x1b[0m"
_GREEN = "\x1b[92m"
_BLUE = "\x1b[94m"
_YELLOW = "\x1b[93m"

_INFO = f"[{_BLUE}INFO{_RESET}]"
_WARN = f"[{_YELLOW}WARN{_RESET}]"


def parse_args() -> argparse.Namespace:
    """Parse and return the CLI arguments.

    Returns:
        An argparse.Namespace object containing the parsed arguments.
    """
    # Some usage guidelines and message for using the program.
    description = "generate blogpost Markdown files in a reproducible manner"
    epilog = f"Â© 2018-{_TIME.year} Somraj Saha <contact@jarmos.dev>"
    blogs = _BLOG_DIR

    # Create the parser to fetch the CLI flags passed to the script.
    parser = argparse.ArgumentParser(description=description, epilog=epilog)

    # Add argument to set the title of the blogpost
    parser.add_argument("title", type=str, help="the title of the blog post")

    # Add argument to set the description of the blogpost
    parser.add_argument(
        "description", type=str, help="the description of the blog post"
    )

    # Add the option to store whether the blog is a draft
    parser.add_argument(
        "-d",
        "--draft",
        action="store_true",
        default=True,
        help='create a draft blogpost, defaults to "True"',
    )

    # Add the option to set the default path to store the blogpost  to
    parser.add_argument(
        "-o",
        "--output",
        type=pathlib.Path,
        default=_BLOG_DIR,
        help=f'directory to save the generated Markdown file to, defaults to "{blogs}"',
    )

    # Add a flag to edit the blog post
    parser.add_argument(
        "-e",
        "--edit",
        action="store_true",
        help='edit the generated Markdown file using $EDITOR, defaults to "False"',
    )

    # Add the option to optionally force creation of the Markdown file (even if it
    # already exists)
    parser.add_argument(
        "-f", "--force", action="store_true", help="overwrite if file already exists"
    )

    # Add the option to provide verbose output when generating the file contents
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="enable verbose output"
    )

    # Parse the arguments and options
    return parser.parse_args()


@dataclass
class Blog:
    """Represents a blog post and provides utilities for generating and writing a
    Markdown file with YAML frontmatter.

    This class is intended to be used as a lightweight content scaffold for
    filesystem-based blogging workflows.
    """

    title: str
    draft: bool
    description: str

    def _slugify(self) -> str:
        """Generate a filesystem-safe slug from the blog title.

        The title is lowercased, spaces are replaced with hyphens and any characters
        other than lowercase alphanumerics and hyphens are removed.

        Returns:
            A lowercase, hyphen-separated string suitable for use as a filename.
        """
        return re.sub(r"[^a-z0-9-]", "", self.title.lower().replace(" ", "-"))

    def _create_template(self) -> str:
        """Create a Markdown template with populated YAML frontmatter.

        The frontmatter includes the blog title, description, publication
        timestamp (UTC), and publication status derived from the `draft`
        flag.

        Returns:
            A Markdown-formatted string containing YAML frontmatter
            followed by placeholder content.
        """
        return (
            "---\n"
            + f"title: {self.title}\n"
            + f"description: {self.description}\n"
            + f"publishedOn: {_TIME}\n"
            + f"status: {'draft' if self.draft else 'published'}\n"
            + "---\n\n"
            + "Add blog content here..."
        )

    def write_file(self, base_dir: pathlib.Path, force: bool) -> pathlib.Path | None:
        """Write the blog post to a Markdown file on disk.

        The file is created under the user's home directory at
        `~/projects/blogposts/blogs`, using a slugified version of the
        title as the filename.

        If a file with the same name already exists and `force` is
        False, the method prints a warning and does not overwrite the
        file.

        Args:
            force: Whether to overwrite an existing file.

        Returns:
            The path to the written Markdown file, or None if the file
            already exists and overwriting was not allowed.
        """
        # Check if the output directory exists, else create it before generating the
        # Markdown file into
        if not base_dir.is_dir():
            base_dir.mkdir(parents=True, exist_ok=True)

        # Sanitize and create the filepath of the Markdown file
        filepath = base_dir / f"{self._slugify()}.md"

        # Print a warning message to the user if the specified file already exists
        if filepath.exists() and not force:
            print(f"WARN {filepath} already exists. Use --force to overwrite.")
            return None

        # Generate the Markdown file along with its specified template content
        content = self._create_template()
        filepath.write_text(content)

        return filepath


def main() -> None:
    """Entrypoint of the script."""
    # Parse the CLI flags and options
    args = parse_args()
    editor = os.getenv("EDITOR")

    # Create an instance of "Blog" to generate a blogpost from
    blog = Blog(title=args.title, draft=args.draft, description=args.description)

    # Write the blogpost to disk and get its filepath
    filepath = blog.write_file(base_dir=args.output, force=args.force)

    # Print useful guidelines to edit the template if it was successfully generated
    if filepath and editor:
        print(f"{_INFO} Blog template is generated at {str(filepath)}")
        print(f"{_INFO} Start editing it by running these commands:\n")
        print(f"{_GREEN}\tcd {filepath.parent}\n\t{editor} {filepath}{_RESET}")

        # Open the file using the editor if the script is allowed to do so
        if args.edit:
            subprocess.run([editor, filepath])


if __name__ == "__main__":
    main()
