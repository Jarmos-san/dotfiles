#!/usr/bin/env python3

"""
Script to generate and automate the process of creating a blogpost.

The script takes user input, either through STDIN or CLI flags to generate a Markdown
file for my blog. The intention of using the script for the purpose is to reproducibly
generate and manage each Markdown file along with some necessary metadata which can be
quite cumbersome to remember every time.

Author: Somraj Saha <contact@jarmos.dev>
License: MIT (see the LICENSE document for more details)

TODO: Provide a usage guide.
"""

import argparse
import datetime
import pathlib
import re

# The current timestamp during the template generation process
_TIME = datetime.datetime.now(datetime.timezone.utc)
_BLOG_DIR = pathlib.Path.home() / "projects" / "blogposts"


def parse_args() -> argparse.Namespace:
    """Parse and return the CLI arguments.

    Returns:
        An argparse.Namespace object containing the parsed arguments.
    """
    # Some usage guidelines and message for using the program.
    description = "generate blogpost Markdown files in a reproducible manner"
    epilog = f"Â© 2018-{_TIME.year} Somraj Saha <contact@jarmos.dev>"
    blogs = _BLOG_DIR

    # Create the parser to fetch the CLI flags passed to the script.
    parser = argparse.ArgumentParser(description=description, epilog=epilog)

    # Add argument to set the title of the blogpost
    parser.add_argument("title", type=str, help="the title of the blog post")

    # Add the option to store whether the blog is a draft
    parser.add_argument(
        "-d",
        "--draft",
        action="store_true",
        default=True,
        help='create a draft blogpost, defaults to "True"',
    )

    # Add the option to set the default path to store the blogpost  to
    parser.add_argument(
        "-o",
        "--output",
        type=pathlib.Path,
        default=_BLOG_DIR,
        help=f"directory to save the generated Markdown file to, defaults to {blogs}",
    )

    # Add the option to optionally force creation of the Markdown file (even if it
    # already exists)
    parser.add_argument(
        "-f", "--force", action="store_true", help="overwrite if file already exists"
    )

    # Add the option to provide verbose output when generating the file contents
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="enable verbose output"
    )

    # Parse the arguments and options
    return parser.parse_args()


def slugify(title: str) -> str:
    """Convert a post title to a filesystem-safe slug.

    Replaces spaces with hyphens and removes any alphanumeric characters.

    Args:
        title: The title of the blog post.

    Returns:
        A lowercase, hyphen-seperated string safe for filenames.
    """
    return re.sub(r"[^a-z0-9-]", "", title.lower().replace(" ", "-"))


def generate_content(title: str, draft: bool) -> str:
    """Generate Markdown content with YAML frontmatter for the blogpost.

    Args:
        title: The title of the blogpost.
        draft: Whether the blogpost should be marked as draft.

    Returns:
        A string containing the Markdown template with populated frontmatter.
    """
    now = _TIME
    status = "draft" if draft else "published"
    description = "Lorem ipsum"

    return f"""---
title: {title}
description: {description}
publishedOn: {now}
status: {status}
---

Add blog content here...
"""


def write_file(
    title: str, output: pathlib.Path, draft: bool, force: bool, verbose: bool
) -> pathlib.Path | None:
    """Generate a Markdown file for a new blog post.

    This function handles the file naming, existence checks, content generation and
    output messages based on the provided arguments.

    Args:
        title: The title of the blog post.
        output: The directory where the Markdown file will be generated at.
        draft: Whether the blogpost should be marked as draft.
        force: Whether to overwrite the file if it already exists.
        verbose: Whether to print detailed output messages.
    """
    # Check if the output directory exists, else create it before generating the
    # Markdown file into.
    if not pathlib.Path(output).is_dir():
        pathlib.Path(output).mkdir(parents=True, exist_ok=True)

    # Sanitize and create the filepath of the Markdown file
    filepath = output / f"{slugify(title)}.md"

    # Print a warning message to the user if the specified file already exists
    if filepath.exists() and not force:
        print(f"[WARN] {filepath} already exists. Use --force to overwrite.")
        return None

    # Generate the Markdown file along with its specified template content
    content = generate_content(title, draft)
    filepath.write_text(content)

    # If the verbose option is enabled, print a verbose output for the user at STDOUT
    if verbose:
        print(f"[INFO] Created {filepath.resolve()}")

    return filepath


def main() -> None:
    """Entrypoint of the script."""
    # Parse the CLI flags and options
    args = parse_args()

    # Get the filepath to the generated template
    filepath = write_file(args.title, args.output, args.draft, args.force, args.verbose)

    # Print useful guidelines to edit the template if it was succesfully generated
    if filepath:
        print(f"[INFO] Blog template is generated at {str(filepath)}")
        print("[INFO] Start editing it by running these commands")
        print(f"\tcd {filepath.parent}\n\tnvim {filepath}")


if __name__ == "__main__":
    main()
