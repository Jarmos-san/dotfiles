#!/usr/bin/env python3

"""
Script to generate and automate the process of creating a blogpost.

The script takes user input, either through STDIN or CLI flags to generate a Markdown
file for my blog. The intention of using the script for the purpose is to reproducibly
generate and manage each Markdown file along with some necessary metadata which can be
quite cumbersome to remember every time.

Author: Somraj Saha <contact@jarmos.dev>
License: MIT (see the LICENSE document for more details)

TODO: Provide a usage guide.
"""

import argparse
import datetime
import logging
import os
import pathlib
import re
import shlex
import subprocess
from dataclasses import dataclass

# The current timestamp during the template generation process
_BLOG_DIR = pathlib.Path.home() / "projects" / "blogposts" / "blogs"


def configure_logging(level: int, name: str = __name__) -> logging.Logger:
    """Configure and return a logger with a console handler and custom formatting.

    The function initialises or retrieves a logger with the given name, sets its logging
    level, attaches a stream handler which outputs to STDOUT and applies a simple,
    structured log message format.

    **NOTE**: The function unconditionally adds a new `StreamHandler` each time it is
    called. Hence, callers should ensure it is not invoked repeatedly for the same
    logger name unless multiple handlers are desired.

    Args:
        level: The logging level to apply (e.g., logging.INFO, logging.DEBUG).
        name: The name of the logger to configure. Defaults to the caller's module name.

    Returns:
        A configured `logging.Logger` instance.
    """
    # Set the name of the root logger
    logger = logging.getLogger(name)
    logger.setLevel(level)
    logger.propagate = False

    # Configure the formatting style of the log messages
    formatter = logging.Formatter("[{levelname}] - {message}", style="{")

    # Set the logger to send the messages to the console output
    if not logger.handlers:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)

    return logger


def parse_args() -> argparse.Namespace:
    """Parse and return the CLI arguments.

    Returns:
        An argparse.Namespace object containing the parsed arguments.
    """
    current_year = datetime.datetime.now(datetime.timezone.utc).year

    # Some usage guidelines and message for using the program.
    description = "generate blogpost Markdown files in a reproducible manner"
    epilog = f"Â© 2018-{current_year} Somraj Saha <contact@jarmos.dev>"
    blogs = _BLOG_DIR

    # Create the parser to fetch the CLI flags passed to the script.
    parser = argparse.ArgumentParser(description=description, epilog=epilog)

    # Add argument to set the title of the blogpost
    parser.add_argument("title", type=str, help="the title of the blog post")

    # Add argument to set the description of the blogpost
    parser.add_argument(
        "description", nargs="?", type=str, help="the description of the blog post"
    )

    # Add the option to store whether the blog is a draft
    parser.add_argument(
        "-D",
        "--draft",
        action="store_true",
        default=True,
        help='create a draft blogpost, defaults to "True"',
    )

    # Add the option to set the default path to store the blogpost  to
    parser.add_argument(
        "-o",
        "--output",
        type=pathlib.Path,
        default=_BLOG_DIR,
        help=f'directory to save the generated Markdown file to, defaults to "{blogs}"',
    )

    # Add a flag to edit the blog post
    parser.add_argument(
        "-e",
        "--edit",
        action="store_true",
        help='edit the generated Markdown file using $EDITOR, defaults to "False"',
    )

    # Add the option to optionally force creation of the Markdown file (even if it
    # already exists)
    parser.add_argument(
        "-f", "--force", action="store_true", help="overwrite if file already exists"
    )

    # Add the option to provide verbose output when generating the file contents
    parser.add_argument(
        "-d", "--debug", action="store_true", help="enable verbose output"
    )

    # Parse the arguments and options
    return parser.parse_args()


@dataclass
class Blog:
    """Represents a blog post and provides utilities for generating and writing a
    Markdown file with YAML frontmatter.

    This class is intended to be used as a lightweight content scaffold for
    filesystem-based blogging workflows.
    """

    title: str
    draft: bool
    description: str

    def _slugify(self) -> str:
        """Generate a filesystem-safe slug from the blog title.

        The title is lowercased, spaces are replaced with hyphens and any characters
        other than lowercase alphanumerics and hyphens are removed.

        Returns:
            A lowercase, hyphen-separated string suitable for use as a filename.

        Raises:
            ValueError if the title cannot be slugified for some reason.
        """
        slug = re.sub(r"[^a-z0-9]+", "-", self.title.lower())

        if not slug:
            raise ValueError("Title cannot be converted into a valid filename")

        return slug.strip("-")

    def _create_template(self) -> str:
        """Create a Markdown template with populated YAML frontmatter.

        The frontmatter includes the blog title, description, publication
        timestamp (UTC), and publication status derived from the `draft`
        flag.

        Returns:
            A Markdown-formatted string containing YAML frontmatter
            followed by placeholder content.
        """
        timestamp = datetime.datetime.now(datetime.timezone.utc)

        return (
            "---\n"
            + f"title: {self.title}\n"
            + f"description: {self.description}\n"
            + f"publishedOn: {timestamp}\n"
            + f"status: {'draft' if self.draft else 'published'}\n"
            + "coverImage:"
            + "  url: https://example.com"
            + "  alt: Lorem ipsum."
            + "---\n\n"
            + "Add blog content here..."
        )

    def write_file(
        self, base_dir: pathlib.Path, force: bool, logger: logging.Logger
    ) -> pathlib.Path | None:
        """Write the blog post to a Markdown file on disk.

        The file is created under the user's home directory at
        `~/projects/blogposts/blogs`, using a slugified version of the
        title as the filename.

        If a file with the same name already exists and `force` is
        False, the method prints a warning and does not overwrite the
        file.

        Args:
            base_dir (pathlib.Path): The base directory path where the Markdown file
                will be generated at.
            force (bool): Whether to overwrite an existing file to replace it with a new
                file.
            logger (logging.Logger): An instance of `logging.Logger` to print log
                messages to the log handler.

        Returns:
            The path to the written Markdown file, or None if the file
            already exists and overwriting was not allowed.
        """
        # Check if the output directory exists, else create it before generating the
        # Markdown file into
        if not base_dir.is_dir():
            base_dir.mkdir(parents=True, exist_ok=True)

        # Sanitize and create the filepath of the Markdown file
        filepath = base_dir / f"{self._slugify()}.md"

        # Print a warning message to the user if the specified file already exists
        if filepath.exists() and not force:
            logger.warning(f"{filepath} already exists")
            logger.info('Use the "--force" flag to overwrite the existing file')

            return None

        # Generate the Markdown file along with its specified template content
        content = self._create_template()
        filepath.write_text(content, encoding="utf-8")

        return filepath


def main() -> None:
    """Entrypoint of the script."""
    # Parse the CLI arguments
    args = parse_args()

    # Create an instance of "Logger" to print log messages
    logger = configure_logging(logging.DEBUG if args.debug else logging.INFO)

    # Set the editor command
    editor = os.getenv("EDITOR")

    if not args.description:
        description = input("Description: ")
    else:
        description = args.description

    logger.debug("Title=%s", args.title)
    logger.debug("Draft=%s", args.draft)
    logger.debug("Description=%s", description)

    # Create an instance of "Blog" to generate a blogpost from
    blog = Blog(title=args.title, draft=args.draft, description=description)

    # Write the blogpost to disk and get its filepath
    filepath = blog.write_file(base_dir=args.output, force=args.force, logger=logger)

    # Set the editor command which can be invoked directly from the script
    cmd = None
    if editor:
        cmd = shlex.split(editor) + [str(filepath)]

    # Print useful guidelines to edit the template if it was successfully generated
    if filepath and editor:
        logger.info(f"Blog template is generated at {str(filepath)}")
        logger.info(
            "Start editing it by running these commands:\n\n\t\x1b[92mcd "
            + f"{filepath.parent}\n\t{editor} {filepath}\x1b[0m"
        )

        # Open the file using the editor if the script is allowed to do so
        if args.edit and cmd:
            result = subprocess.run(cmd)
            if result.returncode != 0:
                logger.error(f'"{cmd}" command exited with a non-zero status')


if __name__ == "__main__":
    main()
