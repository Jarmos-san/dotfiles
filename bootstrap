#!/usr/bin/env python3

"""Script to automate the setup process of a fresh new development environment.

Author: Somraj Saha <somraj.saha@weburz.com>
License: MIT
"""

import platform
import subprocess
import sys
from argparse import ArgumentParser, Namespace
from datetime import datetime
from logging import DEBUG, INFO, Formatter, Logger, StreamHandler, getLogger


def configure_logging(level: int) -> Logger:
    """Configure and return a console logger.

    This function creates (or retrieves) a logger with a given name, set it's logging
    level and attaches a stream handler with a custom formatted log message if no
    handlers are already present.

    Args:
        level: The logging level to be set on the logger and its handler (e.g.,
            `logging.DEBUG`, `logging.INFO`).
        name: The name of the logger to configure. Defaults to the name of the current
            module.

    Returns:
        A configured `logging.Logger` instance.
    """
    # Get a logger and set it's name to the name of the current module
    logger = getLogger(__name__)

    # Set the logging level for the root log handler
    logger.setLevel(level)

    # Format the log message to provide contextual information about the log level name
    # and its associated log message
    fmt = Formatter("[%(levelname)s] - %(message)s")

    # Attach a log handler to print the log messages to STDOUT
    if not logger.handlers:
        console_handler = StreamHandler()
        console_handler.setLevel(level)
        console_handler.setFormatter(fmt)
        logger.addHandler(console_handler)

    return logger


def parse_args() -> Namespace:
    """Parse and return the CLI arguments.

    Initialises an argument parser with program metadata and parses arguments provided
    via the command-line.

    Returns:
        An `argparse.Namespace` object containing the parsed command-line arguments.
    """
    # Get the current year which is used in the program's description
    current_year = datetime.now().year

    # Create a parser instance to attach the CLI arguments to
    parser = ArgumentParser(
        description="bootstrap a fresh new development environment.",
        epilog=f"copyright 2018-{current_year} Somraj Saha <somraj.saha@weburz.com>",
    )

    # Flag to enable debug mode for the script
    parser.add_argument(
        "--debug", action="store_true", help="enable debug mode for the script"
    )

    # Parse the CLI arguments and return them
    return parser.parse_args()


def update_system(logger: Logger) -> None:
    """Update system packages using the native package manager.

    Detects the underlying Linux distribution using freedesktop OS metadata and executes
    the appropriate system package update and upgrade commands via the distribution's
    package manager.

    Args:
        logger: The `logging.Logger` instance used to emit debug, informational and
            error messages during the update process.

    Raises:
        SystemExit: If the Operating System cannot be identified or is not supported.
    """
    # Get the name of the OS to run updates on
    os_name = platform.freedesktop_os_release().get("NAME")

    logger.debug("Identified OS name as: %s", os_name)
    logger.info("Running system updates...")

    # Run system updates based on the Operating System's package manager
    match os_name:
        case "Ubuntu" | "Debian":
            # Command to update the apt-cache
            update = ["sudo", "apt-get", "update"]

            # Command to update the system packages
            upgrade = ["sudo", "apt-get", "upgrade", "--yes"]

            logger.debug('Running "%s" to update the apt-cache', " ".join(update))
            subprocess.run(update)

            logger.debug('Running "%s" to upgrade the apt packages', " ".join(upgrade))
            subprocess.run(upgrade)
        case "Fedora":
            # Command to update the dnf packages
            cmd = ["sudo", "dnf", "upgrade", "--refresh", "--assumeyes"]
            logger.debug('Running "%s" to upgrade the dnf packages', " ".join(cmd))
            subprocess.run(cmd)
        case _:
            logger.error("Failed to identify OS name...exiting now!")
            sys.exit(1)


def main() -> None:
    """Program entry point.

    Parses command-line arguments, configure logging and executes the main application
    logic.
    """
    # Parse the CLI arguments
    args = parse_args()

    # Set the logging level based on the argument passed to the script
    if args.debug:
        level = DEBUG
    else:
        level = INFO

    # Configure a logger and provide it a logging level
    logger = configure_logging(level)

    # Update the system before running automated setup
    update_system(logger)


if __name__ == "__main__":
    main()
